{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A real world example of using this is in our library, the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture"},{"type":"text","text":". That library vends a "},{"type":"codeVoice","code":"TestStore"},{"type":"text","text":" type whose purpose is to make it easy to write tests for your applicationâ€™s logic. The "},{"type":"codeVoice","code":"TestStore"},{"type":"text","text":" uses "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" internally, and so that forces us to move the code to a dedicated test support module. However, due to how SPM works you cannot currently have that module in the same package as the main module, and so we would be forced to extract it to a separate "},{"type":"emphasis","inlineContent":[{"type":"text","text":"repo"}]},{"type":"text","text":". By loading "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" dynamically we can keep the code where it belongs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As another example, letâ€™s say you have an analytics dependency that is used all over your application:"}]},{"type":"codeListing","syntax":"swift","code":["struct AnalyticsClient {","  var track: (Event) -> Void","","  struct Event: Equatable {","    var name: String","    var properties: [String: String]","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you are disciplined about injecting dependencies, you probably have a lot of objects that take an analytics client as an argument (or maybe some other fancy form of DI):"}]},{"type":"codeListing","syntax":"swift","code":["class LoginViewModel: ObservableObject {","  ...","","  init(analytics: AnalyticsClient) {","    ...","  }","","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When testing this view model you will need to provide an analytics client. Typically this means you will construct some kind of â€œtestâ€ analytics client that buffers events into an array, rather than sending live events to a server, so that you can assert on what events were tracked during a test:"}]},{"type":"codeListing","syntax":"swift","code":["func testLogin() {","  var events: [AnalyticsClient.Event] = []","  let viewModel = LoginViewModel(","    analytics: .test { events.append($0) }","  )","","  ...","","  XCTAssertEqual(events, [.init(name: \"Login Success\")])","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This works really well, and itâ€™s a great way to get test coverage on something that is notoriously difficult to test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, some tests may not use analytics at all. It would make the test suite stronger if the tests that donâ€™t use the client could prove that itâ€™s never used. This would mean when new events are tracked you could be instantly notified of which test cases need to be updated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way to do this is to create an instance of the "},{"type":"codeVoice","code":"AnalyticsClient"},{"type":"text","text":" type that simply performs an "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" inside the "},{"type":"codeVoice","code":"track"},{"type":"text","text":" endpoint:"}]},{"type":"codeListing","syntax":"swift","code":["import XCTest","","extension AnalyticsClient {","  static let unimplemented = Self(","    track: { _ in XCTFail(\"\\(Self.self).track is unimplemented.\") }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With this you can write a test that proves analytics are never tracked, and even better you donâ€™t have to worry about buffering events into an array anymore:"}]},{"type":"codeListing","syntax":"swift","code":["func testValidation() {","  let viewModel = LoginViewModel(","    analytics: .unimplemented","  )","","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, you cannot ship this code with the target that defines "},{"type":"codeVoice","code":"AnalyticsClient"},{"type":"text","text":". You either need to extract it out to a test support module (which means "},{"type":"codeVoice","code":"AnalyticsClient"},{"type":"text","text":" must also be extracted), or the code must be confined to a test target and thus not shareable."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, with XCTest Dynamic Overlay we can have our cake and eat it too ðŸ˜‹. We can define both the client type and the unimplemented instance right next to each in application code without needing to extract out needless modules or targets:"}]},{"type":"codeListing","syntax":"swift","code":["struct AnalyticsClient {","  var track: (Event) -> Void","","  struct Event: Equatable {","    var name: String","    var properties: [String: String]","  }","}","","import XCTestDynamicOverlay","","extension AnalyticsClient {","  static let unimplemented = Self(","    track: { _ in XCTFail(\"\\(Self.self).track is unimplemented.\") }","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"XCTest Dynamic Overlay also comes with a helper that simplifies this exact pattern: "},{"type":"codeVoice","code":"XCTUnimplemented"},{"type":"text","text":". It creates failing closures for you:"}]},{"type":"codeListing","syntax":"swift","code":["extension AnalyticsClient {","  static let unimplemented = Self(","    track: XCTUnimplemented(\"\\(Self.self).track\")","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And it can simplify the work of more complex dependency endpoints, which can throw or need to return a value:"}]},{"type":"codeListing","syntax":"swift","code":["struct AppDependencies {","  var date: () -> Date = Date.init,","  var fetchUser: (User.ID) async throws -> User,","  var uuid: () -> UUID = UUID.init","}","","extension AppDependencies {","  static let unimplemented = Self(","    date: XCTUnimplemented(\"\\(Self.self).date\", placeholder: Date()),","    fetchUser: XCTUnimplemented(\"\\(Self.self).fetchUser\"),","    date: XCTUnimplemented(\"\\(Self.self).uuid\", placeholder: UUID())","  )","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The above "},{"type":"codeVoice","code":"placeholder"},{"type":"text","text":" parameters can be left off, but will fatal error when the endpoint is called."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/xctestdynamicoverlay\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/XCTestDynamicOverlay\/documentation\/XCTestDynamicOverlay\/GettingStarted","interfaceLanguage":"swift"},"kind":"article","metadata":{"roleHeading":"Article","title":"Getting Started","role":"article","modules":[{"name":"XCTestDynamicOverlay"}]},"hierarchy":{"paths":[["doc:\/\/XCTestDynamicOverlay\/documentation\/XCTestDynamicOverlay"]]},"references":{"doc://XCTestDynamicOverlay/documentation/XCTestDynamicOverlay":{"role":"collection","title":"XCTestDynamicOverlay","abstract":[{"type":"text","text":"Define XCTest assertion helpers directly in your application and library code."}],"identifier":"doc:\/\/XCTestDynamicOverlay\/documentation\/XCTestDynamicOverlay","kind":"symbol","type":"topic","url":"\/documentation\/xctestdynamicoverlay"},"https://github.com/pointfreeco/swift-composable-architecture":{"title":"Composable Architecture","titleInlineContent":[{"type":"text","text":"Composable Architecture"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture","url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture"}}}